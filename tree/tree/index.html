<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>圣诞快乐 | Holiday Magic</title>
    
    <!-- 字体换成系统字体，加快加载 -->
    <style>
        :root { --gold: #d4af37; --cream: #fceea7; --black: #000000; }
        body { margin: 0; overflow: hidden; background-color: var(--black); font-family: 'Times New Roman', serif; color: var(--cream); user-select: none; -webkit-user-select: none; touch-action: none; }
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; transition: opacity 0.5s ease; }
        .ui-hidden { opacity: 0 !important; pointer-events: none !important; }
        h1 { font-family: serif; font-weight: bold; font-size: min(48px, 8vw); text-align: center; margin-top: 20px; background: linear-gradient(to bottom, #ffffff, var(--gold)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 20px rgba(212, 175, 55, 0.5); letter-spacing: 2px; width: 100%; }
        .controls-area { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: auto; display: flex; flex-direction: column; align-items: center; gap: 10px; width: 90%; max-width: 400px; }
        .upload-wrapper { position: relative; overflow: hidden; display: inline-block; }
        .btn { background: rgba(20, 20, 20, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid var(--gold); color: var(--gold); font-family: serif; padding: 12px 24px; font-size: 14px; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px; box-shadow: 0 0 10px rgba(212, 175, 55, 0.1); border-radius: 4px; }
        input[type="file"] { position: absolute; top: 0; left: 0; opacity: 0; cursor: pointer; height: 100%; width: 100%; }
        .hint { font-size: 12px; color: rgba(252, 238, 167, 0.6); margin-top: 5px; text-shadow: 0 2px 4px black; }
        #loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--black); z-index: 999; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.8s ease; }
        .spinner { width: 40px; height: 40px; border: 2px solid rgba(212, 175, 55, 0.1); border-top: 2px solid var(--gold); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        .loading-text { font-family: serif; color: var(--gold); letter-spacing: 3px; font-size: 14px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #vision-container { position: absolute; bottom: 0; right: 0; opacity: 0; pointer-events: none; width: 1px; height: 1px; overflow: hidden; }
    </style>

    <!-- Import Map: 换成国内极速 CDN (BootCDN 或 Staticfile) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.staticfile.net/three.js/0.160.0/three.module.js",
                "three/addons/": "https://cdn.staticfile.net/three.js/0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>
    <div id="loader"><div class="spinner"></div><div class="loading-text">正在加载魔法...</div></div>
    <div id="ui-container">
        <h1>Merry Christmas</h1>
        <div class="controls-area">
            <div class="upload-wrapper">
                <button class="btn">添加照片</button>
                <input type="file" id="imageInput" accept="image/*">
            </div>
            <div class="hint">双击屏幕 隐藏/显示 界面</div>
            <div class="hint" id="gesture-hint">正在启动摄像头...</div>
        </div>
    </div>
    <div id="vision-container"><video id="webcam" autoplay playsinline webkit-playsinline></video></div>

    <script type="module">
        import * as THREE from 'three';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        const STATE = { mode: 'TREE', targetPhoto: null, handRotation: { x: 0, y: 0 }, isLoaded: false };

        class Particle {
            constructor(mesh) {
                this.mesh = mesh;
                this.velocity = new THREE.Vector3((Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05, (Math.random()-0.5)*0.05);
                this.rotSpeed = new THREE.Vector3((Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02);
                this.treePos = new THREE.Vector3();
                this.treeRot = new THREE.Euler();
                this.calculateTreePosition();
            }
            calculateTreePosition() {
                const t = Math.random(); 
                const height = 30 * t - 15; 
                const radius = (12 * (1 - t) + 1); 
                const angle = t * 50 * Math.PI + Math.random() * Math.PI * 2;
                this.treePos.set(Math.cos(angle) * radius + (Math.random()-0.5)*2, height, Math.sin(angle) * radius + (Math.random()-0.5)*2);
                this.treeRot.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            }
            update(delta, time) {
                let targetPos = new THREE.Vector3();
                let targetScale = 1.0;
                if (STATE.mode === 'TREE') {
                    targetPos.copy(this.treePos); targetPos.y += Math.sin(time + this.treePos.x) * 0.5;
                } else if (STATE.mode === 'SCATTER') {
                    if (this.mesh.position.length() > 25) this.velocity.negate();
                    this.mesh.position.add(this.velocity); this.mesh.rotation.x += this.rotSpeed.x; return;
                } else if (STATE.mode === 'FOCUS') {
                    if (this === STATE.targetPhoto) { targetPos.set(0, 2, 35); this.mesh.rotation.set(0,0,0); targetScale = 4.5; }
                    else { targetPos.copy(this.treePos).multiplyScalar(1.5); }
                }
                const speed = 3.0 * delta;
                this.mesh.position.lerp(targetPos, speed);
                if (STATE.mode !== 'SCATTER' && (STATE.mode !== 'FOCUS' || this !== STATE.targetPhoto)) {
                    this.mesh.rotation.x += (this.treeRot.x - this.mesh.rotation.x) * speed;
                    this.mesh.rotation.y += (this.treeRot.y - this.mesh.rotation.y) * speed;
                    this.mesh.rotation.z += (this.treeRot.z - this.mesh.rotation.z) * speed;
                }
                this.mesh.scale.setScalar(THREE.MathUtils.lerp(this.mesh.scale.x, targetScale, speed));
            }
        }

        class ChristmasExperience {
            constructor() { this.container = document.body; this.particles = []; this.photos = []; this.clock = new THREE.Clock(); }
            async init() {
                this.setupScene(); this.setupLights(); this.setupPostProcessing();
                this.generateMaterials(); this.generateCandyCaneTexture(); this.createParticles(); this.createPhotoWall();
                this.setupInteraction();
                try { await this.setupMediaPipe(); document.getElementById('gesture-hint').innerText = "手势就绪: 捏合=照片 / 握拳=树 / 张手=散开"; } 
                catch (e) { console.warn(e); document.getElementById('gesture-hint').innerText = "无法启动摄像头，请使用触摸交互"; }
                STATE.isLoaded = true;
                setTimeout(() => { document.getElementById('loader').style.opacity = '0'; setTimeout(() => document.getElementById('loader').remove(), 800); }, 1000);
                this.animate();
            }
            setupScene() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.toneMapping = THREE.ReinhardToneMapping; this.renderer.toneMappingExposure = 2.2; this.container.appendChild(this.renderer.domElement);
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 200); this.camera.position.set(0, 2, 50);
                this.scene = new THREE.Scene(); const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                this.scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
                this.mainGroup = new THREE.Group(); this.scene.add(this.mainGroup);
                window.addEventListener('resize', () => { this.camera.aspect = window.innerWidth/window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); this.composer.setSize(window.innerWidth, window.innerHeight); });
            }
            setupLights() {
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const c = new THREE.PointLight(0xffaa00, 2, 50); c.position.set(0, 0, 0); this.mainGroup.add(c);
                const s1 = new THREE.SpotLight(0xd4af37, 1200); s1.position.set(30, 40, 40); s1.angle=0.5; s1.penumbra=0.5; this.scene.add(s1);
                const s2 = new THREE.SpotLight(0x4455ff, 600); s2.position.set(-30, 20, -30); s2.angle=0.6; s2.penumbra=0.5; this.scene.add(s2);
            }
            setupPostProcessing() { this.composer = new EffectComposer(this.renderer); this.composer.addPass(new RenderPass(this.scene, this.camera)); this.composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.45, 0.4, 0.7)); }
            generateMaterials() {
                this.matGold = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8, roughness: 0.2 });
                this.matGreen = new THREE.MeshStandardMaterial({ color: 0x053315, metalness: 0.3, roughness: 0.6 });
                this.matRedGloss = new THREE.MeshPhysicalMaterial({ color: 0xaa0000, metalness: 0.1, roughness: 0.1, clearcoat: 1.0 });
                this.matGoldGloss = new THREE.MeshPhysicalMaterial({ color: 0xffd700, metalness: 0.7, roughness: 0.2, clearcoat: 0.5 });
            }
            generateCandyCaneTexture() {
                const c = document.createElement('canvas'); c.width = 128; c.height = 128; const ctx = c.getContext('2d');
                ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, 128, 128); ctx.fillStyle = '#cc0000'; ctx.beginPath();
                for (let i = -128; i < 256; i += 32) { ctx.moveTo(i, 0); ctx.lineTo(i + 32, 128); ctx.lineTo(i + 48, 128); ctx.lineTo(i + 16, 0); } ctx.fill();
                this.candyTexture = new THREE.CanvasTexture(c); this.candyTexture.wrapS = THREE.RepeatWrapping; this.candyTexture.wrapT = THREE.RepeatWrapping; this.candyTexture.repeat.set(1, 8); this.candyTexture.colorSpace = THREE.SRGBColorSpace;
            }
            createParticles() {
                const box = new THREE.BoxGeometry(0.5, 0.5, 0.5); const sphere = new THREE.SphereGeometry(0.3, 16, 16);
                for (let i = 0; i < 1200; i++) {
                    let mesh; const r = Math.random();
                    if (r < 0.4) mesh = new THREE.Mesh(box, Math.random()>0.5?this.matGold:this.matGreen);
                    else if (r < 0.8) mesh = new THREE.Mesh(sphere, Math.random()>0.5?this.matRedGloss:this.matGoldGloss);
                    else {
                        const path = new THREE.CatmullRomCurve3([new THREE.Vector3(0,-0.5,0), new THREE.Vector3(0,0.5,0), new THREE.Vector3(0.2,0.7,0), new THREE.Vector3(0.4,0.5,0)]);
                        mesh = new THREE.Mesh(new THREE.TubeGeometry(path, 4, 0.08, 6, false), new THREE.MeshStandardMaterial({ map: this.candyTexture, roughness: 0.3 }));
                    }
                    this.mainGroup.add(mesh); this.particles.push(new Particle(mesh));
                }
                const tiny = new THREE.BufferGeometry(); const v = []; for(let i=0; i<2000; i++) v.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
                tiny.setAttribute('position', new THREE.Float32BufferAttribute(v, 3));
                this.dustSystem = new THREE.Points(tiny, new THREE.PointsMaterial({ color: 0xffffee, size: 0.1, transparent: true, opacity: 0.6 })); this.scene.add(this.dustSystem);
            }
            createPhotoWall() {
                const c = document.createElement('canvas'); c.width = 512; c.height = 512; const ctx = c.getContext('2d');
                ctx.fillStyle = '#110000'; ctx.fillRect(0,0,512,512); ctx.font = '60px serif'; ctx.fillStyle = '#d4af37'; ctx.textAlign = 'center'; ctx.fillText('JOYEUX', 256, 220); ctx.fillText('NOEL', 256, 300);
                const t = new THREE.CanvasTexture(c); t.colorSpace = THREE.SRGBColorSpace; this.addPhotoToScene(t);
            }
            addPhotoToScene(t) {
                const g = new THREE.Group(); g.add(new THREE.Mesh(new THREE.BoxGeometry(2.2, 2.2, 0.2), this.matGold));
                const p = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: t })); p.position.z = 0.11; g.add(p);
                this.mainGroup.add(g); const pt = new Particle(g); this.particles.push(pt); this.photos.push(pt); pt.calculateTreePosition();
            }
            setupInteraction() {
                document.getElementById('imageInput').addEventListener('change', (ev) => {
                    const f = ev.target.files[0]; if(!f)return;
                    const r = new FileReader(); r.onload = (e) => new THREE.TextureLoader().load(e.target.result, (t) => { t.colorSpace = THREE.SRGBColorSpace; this.addPhotoToScene(t); }); r.readAsDataURL(f);
                });
                let lastTap = 0; window.addEventListener('touchstart', (e) => {
                    if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
                        const ct = new Date().getTime(); if (ct - lastTap < 500 && ct - lastTap > 0) document.getElementById('ui-container').classList.toggle('ui-hidden'); lastTap = ct;
                    }
                });
            }
            
            // --- 核心修改：使用本地 WASM 文件夹 ---
            async setupMediaPipe() {
                // 1. 指定本地 wasm 路径
                const vision = await FilesetResolver.forVisionTasks("./wasm");
                
                // 2. 指定本地模型路径
                this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "./wasm/hand_landmarker.task", // 本地模型文件
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                const video = document.getElementById('webcam');
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user", width: { ideal: 320 }, height: { ideal: 240 } } });
                video.srcObject = stream;
                return new Promise((resolve) => { video.addEventListener("loadeddata", () => { this.predictWebcam(); resolve(); }); });
            }

            async predictWebcam() {
                const video = document.getElementById('webcam'); let lastVideoTime = -1;
                const renderLoop = async () => {
                    if (video.currentTime !== lastVideoTime) {
                        lastVideoTime = video.currentTime;
                        const result = this.handLandmarker.detectForVideo(video, performance.now());
                        this.processGestures(result);
                    }
                    requestAnimationFrame(renderLoop);
                };
                renderLoop();
            }

            processGestures(result) {
                if (!result.landmarks || result.landmarks.length === 0) { STATE.handRotation.x *= 0.95; STATE.handRotation.y *= 0.95; return; }
                const lm = result.landmarks[0];
                STATE.handRotation.y = (lm[9].x - 0.5) * -3; STATE.handRotation.x = (lm[9].y - 0.5) * 2;
                const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
                const pinch = dist(lm[4], lm[8]);
                let avg = 0; [lm[8],lm[12],lm[16],lm[20]].forEach(t => avg += dist(t, lm[0])); avg /= 4;
                if (pinch < 0.05) { if (STATE.mode !== 'FOCUS') { STATE.mode = 'FOCUS'; if (this.photos.length > 0) STATE.targetPhoto = this.photos[Math.floor(Math.random() * this.photos.length)]; } }
                else if (avg < 0.25) STATE.mode = 'TREE'; else if (avg > 0.4) STATE.mode = 'SCATTER';
                document.getElementById('gesture-hint').innerText = `当前模式: ${STATE.mode}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = this.clock.getDelta(); const time = this.clock.getElapsedTime();
                this.mainGroup.rotation.y += (STATE.handRotation.y - this.mainGroup.rotation.y) * 0.1;
                this.mainGroup.rotation.x += (STATE.handRotation.x - this.mainGroup.rotation.x) * 0.1;
                if (Math.abs(STATE.handRotation.y) < 0.01 && !this.handLandmarker) this.mainGroup.rotation.y += 0.002;
                this.particles.forEach(p => p.update(delta, time));
                if(this.dustSystem) this.dustSystem.rotation.y = time * 0.05;
                this.composer.render();
            }
        }
        new ChristmasExperience().init();
    </script>
</body>
</html>